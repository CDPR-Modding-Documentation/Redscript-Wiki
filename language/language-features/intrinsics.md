---
description: Intrinsics are low-level operations that are natively supported in REDscript.
---

# Intrinsics

<table><thead><tr><th width="202.77492217597387">Intrinsic</th><th width="312.49322796785424">Type</th><th>Description</th></tr></thead><tbody><tr><td><code>Equals</code></td><td><code>(A, A) -> Bool</code></td><td>Equality check (for references, enums, strings and booleans)</td></tr><tr><td><code>NotEquals</code></td><td><code>(A, A) -> Bool</code></td><td>Inequality check (same as above)</td></tr><tr><td><code>IsDefined</code></td><td><p><code>(ref&#x3C;A>) -> Bool</code></p><p><code>(wref&#x3C;A>) -> Bool</code></p></td><td>Null check</td></tr><tr><td><code>ToString</code></td><td><code>(A) -> String</code></td><td>String conversion</td></tr><tr><td><code>EnumInt</code></td><td><code>(A) -> Int32</code></td><td>Enum-to-Int32 conversion</td></tr><tr><td><code>IntEnum</code></td><td><code>(Int32) -> A</code></td><td>Int32-to-enum conversion</td></tr><tr><td><code>ToVariant</code></td><td><code>(A) -> Variant</code></td><td>Variant constructor</td></tr><tr><td><code>FromVariant</code></td><td><code>(Variant) -> A</code></td><td>Variant extractor (fails at runtime if the type does not match)</td></tr><tr><td><code>ArraySize</code></td><td><p><code>([A]) -> Int32</code></p><p><code>([A; N]) -> Int32</code></p></td><td></td></tr><tr><td><code>ArrayPush</code></td><td><code>([A], A) -> Void</code></td><td>Push item on stack (order is <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">LIFO</a>).</td></tr><tr><td><code>ArrayPop</code></td><td><code>([A]) -> A</code></td><td>Pop item from stack (order is <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">LIFO</a>).</td></tr><tr><td><code>ArrayClear</code></td><td><code>([A]) -> Void</code></td><td></td></tr><tr><td><code>ArrayResize</code></td><td><code>([A], Int32) -> Void</code></td><td></td></tr><tr><td><code>ArrayFindFirst</code></td><td><p><code>([A], A) -> Int32</code></p><p><code>([A; N], A) -> Int32</code></p></td><td></td></tr><tr><td><code>ArrayFindLast</code></td><td><p><code>([A], A) -> Int32</code></p><p><code>([A; N], A) -> Int32</code></p></td><td></td></tr><tr><td><code>ArrayContains</code></td><td><p><code>([A], A) -> Bool</code></p><p><code>([A; N], A) -> Bool</code></p></td><td></td></tr><tr><td><code>ArrayCount</code></td><td><p><code>([A], A) -> Int32</code></p><p><code>([A; N], A) -> Int32</code></p></td><td></td></tr><tr><td><code>ArraySort</code></td><td><code>([A]) -> Void</code></td><td>Only accepts arrays of primitives</td></tr><tr><td><code>ArrayInsert</code></td><td><code>([A], Int32, A) -> Void</code></td><td></td></tr><tr><td><code>ArrayRemove</code></td><td><code>([A], A) -> Bool</code></td><td></td></tr><tr><td><code>ArrayGrow</code></td><td><code>([A], Int32) -> Void</code></td><td></td></tr><tr><td><code>ArrayErase</code></td><td><code>([A], Int32) -> Void</code></td><td></td></tr><tr><td><code>ArrayLast</code></td><td><p><code>([A]) -> A</code></p><p><code>([A; N]) -> A</code></p></td><td></td></tr></tbody></table>

Legend:

* `[A]` - array of A
* `[A; N]` static array of A with size N
