---
description: Built-in types available in the game runtime.
---

# Built-in Types

## Logical Types

<table data-header-hidden><thead><tr><th width="116.33333333333331">Keyword</th><th width="206">Type</th><th>Values</th></tr></thead><tbody><tr><td>Keyword</td><td>Type</td><td>Values</td></tr><tr><td><code>Bool</code></td><td>Boolean logic type</td><td><code>true</code>  <code>false</code></td></tr></tbody></table>

## Integer Types

<table data-header-hidden><thead><tr><th width="116">Keyword</th><th width="207">Type</th><th width="198">Range</th><th>Example</th></tr></thead><tbody><tr><td>Keyword</td><td>Type</td><td>Range</td><td>Example</td></tr><tr><td><code>Int8</code></td><td>8-bit Signed Integer</td><td><code>-128</code> to <code>127</code></td><td><code>let a: Int8 = 161;</code></td></tr><tr><td><code>Uint8</code></td><td>8-bit Unsigned Integer</td><td><code>0</code> to <code>255</code></td><td><code>let a: Uint8 = 161u;</code></td></tr><tr><td><code>Int16</code></td><td>16-bit Signed Integer</td><td><code>-32,768</code> to <code>32,767</code></td><td><code>let a: Int16 = 161;</code></td></tr><tr><td><code>Uint16</code></td><td>16-bit Unsigned Integer</td><td><code>0</code> to <code>65,535</code></td><td><code>let a: Uint16 = 161u;</code></td></tr><tr><td><code>Int32</code></td><td>32-bit Signed Integer</td><td><code>−2,147,483,648</code> to <code>2,147,483,647</code></td><td><code>let a: Int32 = 161;</code></td></tr><tr><td><code>Uint32</code></td><td>32-bit Unsigned Integer</td><td><code>0</code> to <code>4,294,967,295</code></td><td><code>let a: Uint32 = 161u;</code></td></tr><tr><td><code>Int64</code></td><td>64-bit Signed Integer</td><td><code>−9,223,372,036,854,775,808</code> to <code>9,223,372,036,854,775,807</code></td><td><code>let a: Int64 = 161l;</code></td></tr><tr><td><code>Uint64</code></td><td>64-bit Unsigned Integer</td><td><code>0</code> to <code>18,446,744,073,709,551,615</code></td><td><code>let a: Uint64 = 161ul;</code></td></tr></tbody></table>

You can declare inline numbers using `Cast<T>(value)`. It is useful for `Int8`/`Uint8` and `Int16`/`Uint16` for example:

```swift
// Fake function to use:
public static func UseNumber(a: Int8, ua: Uint8, b: Int16, ub: Uint16) -> Void;

// Use explicit cast
UseNumber(Cast<Int8>(127),
          Cast<Uint8>(255u),
          Cast<Int16>(32767),
          Cast<Uint16>(65535u));
```

## Floating-Point Types

<table data-header-hidden><thead><tr><th width="116.33333333333331">Keyword</th><th width="207">Type</th><th width="219">Range</th><th></th></tr></thead><tbody><tr><td>Keyword</td><td>Type</td><td>Range</td><td>Example</td></tr><tr><td><code>Float</code></td><td>32-bit Single-Precision</td><td>6-9 significant decimal digits (<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">more info</a>)</td><td><code>let a: Float = 3.141592;</code></td></tr><tr><td><code>Double</code></td><td>64-bit Double-Precision</td><td>15-17 significant decimal digits (<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">more info</a>)</td><td><code>let a: Double = 3.141592653589793d;</code></td></tr></tbody></table>

## Literal Types

<table data-header-hidden><thead><tr><th width="145">Keyword</th><th width="190">Type</th><th width="82">Prefix</th><th>Example</th></tr></thead><tbody><tr><td>Keyword</td><td>Type</td><td>Prefix</td><td>Example</td></tr><tr><td><code>String</code></td><td>Mutable character string</td><td></td><td><code>"Hello world"</code></td></tr><tr><td><code>CName</code></td><td>Non-mutable string constant</td><td><code>n</code></td><td><code>n"VehicleComponent"</code></td></tr><tr><td><code>ResRef</code></td><td>Resource reference path</td><td><code>r</code></td><td><code>r"base\\anim_cooked.cookedanims"</code></td></tr><tr><td><code>TweakDBID</code></td><td>TweakDB Record ID</td><td><code>t</code></td><td><code>t"Items.RequiredItemStats"</code></td></tr></tbody></table>

`String` values are stored internally as a null-terminated character array, unfortunately the bytecode doesn't support accessing the individual characters as an array.

`CName` values are stored in-engine as a [64-bit hash key](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo\_hash\_function#FNV-1a\_hash) to a interned string pool. Class, function and field names are stored in the CName pool, so any methods that need a dynamic reference a scripted component will use a `CName` value.

`ResRef` values are similar to `CName` values, except they specifically refer to archive resource files and presumably use a separate optimized string pool. Unlike `CName`, `ResRef` doesn't have any defined operators.

`TweakDBID` is used as the primary key for all `*_Record` types stored in TweakDB, the engine's internal database.

## Other Types

<table data-header-hidden><thead><tr><th width="139" align="center">Keyword</th><th>Type</th></tr></thead><tbody><tr><td align="center">Keyword</td><td>Type</td></tr><tr><td align="center"><code>Variant</code></td><td>A dynamic type that can store any other type</td></tr></tbody></table>

## Operators

The RED4 scripting runtime implements most operators as native functions. Only the equals `==` and not equals `!=` operators are implemented in bytecode. The **redscript** compiler provides a number of operator symbols as shorthand.

This table lists the available operators (in precedence block order) and what types support them.

<table data-header-hidden><thead><tr><th width="188">Type</th><th align="center">Symbol</th><th align="center">Logical</th><th align="center">Integer</th><th align="center">Float</th><th align="center">String</th><th align="center">CName</th><th align="center">TweakDBID</th></tr></thead><tbody><tr><td>Type</td><td align="center">Symbol</td><td align="center">Logical</td><td align="center">Integer</td><td align="center">Float</td><td align="center">String</td><td align="center">CName</td><td align="center">TweakDBID</td></tr><tr><td>Negate</td><td align="center"><code>-</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Logical Not</td><td align="center"><code>!</code></td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">✓¹</td></tr><tr><td>Bitwise Not</td><td align="center"><code>~</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Multiplication</td><td align="center"><code>*</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓²</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Division</td><td align="center"><code>/</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Modulo</td><td align="center"><code>%</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Addition</td><td align="center"><code>+</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓³</td><td align="center">✓⁴</td><td align="center">✓⁴</td></tr><tr><td>Subtraction</td><td align="center"><code>-</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Less Than</td><td align="center"><code>&#x3C;</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Less Than or Equal</td><td align="center"><code>&#x3C;=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Greater Than</td><td align="center"><code>></code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Greater Than or Equal</td><td align="center"><code>>=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Equals</td><td align="center"><code>==</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓⁵</td><td align="center">✓</td></tr><tr><td>Not Equals</td><td align="center"><code>!=</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓⁵</td><td align="center">✓</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Logical And</td><td align="center"><code>&#x26;&#x26;</code></td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Logical Or</td><td align="center"><code>||</code></td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Bitwise And</td><td align="center"><code>&#x26;</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Bitwise Or</td><td align="center"><code>|</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Bitwise Xor</td><td align="center"><code>^</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Assign</td><td align="center"><code>=</code></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td>Assign Add</td><td align="center"><code>+=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">✓</td></tr><tr><td>Assign Subtract</td><td align="center"><code>-=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Assign Multiply</td><td align="center"><code>*=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Assign Divide</td><td align="center"><code>/=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Assign Bitwise And</td><td align="center"><code>&#x26;=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td>Assign Bitwise Or</td><td align="center"><code>|=</code></td><td align="center">-</td><td align="center">✓</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr></tbody></table>

### Notes

1. The Logical Not `!` operator for `TweakDBID` is overridden to return `!TDBID.IsValid(a)`
2.  Strings can be multiplied by an `Int32` to repeat the string:

    ```swift
    public static func OperatorMultiply(a: String, count: Int32) -> String
    ```
3. `String` addition is [concatenation](https://en.wikipedia.org/wiki/Concatenation). There are native functions to allow most types can be concatenated with `String`
4. `CName` and `TweakDBID` addition is [concatenation](https://en.wikipedia.org/wiki/Concatenation) (and presumably involves some kind of internal lookup to a known value)
5. The **redscript** compiler doesn't currently support the `==` and `!=` symbols for the `CName` type, use the `Equals(a,b)` and `NotEquals(a,b)` intrinsic functions for now.
